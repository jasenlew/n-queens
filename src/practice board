// we have n
var n = 5;
// create an result array
var result = [];

// add n number of arrays
var arrayMaker = function(n, iteration) {

  iteration = iteration || 0;

  var newArr = [];

  var fill = function() {
    newArr.push(0);
    if (newArr.length < n) {
      fill();
    }
  };

  fill();
  result.push(newArr);

  if (iteration < n) {
    arrayMaker(n, iteration + 1);
  }

};

arrayMaker(15);

console.log(result);

// board[[]];

// n: 3
// c:
// r:
// alreadyOccupiedColumns[]
// board: []
// boards: [b1, b2]


// (1) r
// (2) c

//if c is not in alreadyOccupiedColumns
  //then place a '1' at c r
  //record [c, r] in board
  //if board.length === n
    //boards.push(board)
  //add c to alreadyOccupiedColumns
  //if r + 1 < n
    //go to (1),adding r + 1, c: 0 to the stack
  // (3)
  // pop one element off of board
  // pop one element of alreadyOccupiedColumns
  // else
    // add board to boards

// if c + 1 < n
  // go to (2) with c + 1
// else
  // return this call: go to (3)



//////QUEEN TIME

create a function that takes a coordinate input (rowIndex, colIndex) of the the queen just placed (PURPOSE: add to add to the alreadyOccupiedSquares object... specifically adding a property, which has a [1] key that is a stringified version of the off-limit coordinates and [2] value set to true)


//-->NOTE:




var getAttackedSquares = function(rowIndex, colIndex, addOrRemove) {

  //create storage element for the attacked spaces
  //create var squares element to hold the attackedsquares to be addOrRemoved for the passed in Queen coordinates
  // var stringifiedCoordinates = stringify first two arguments

  // if the stringified version of rowIndex, colIndex already exist in storage element --> storage[stringified arguments] is true
    //squares = value of the stringified version of rowI,colI
  // else
    //col
      // i = rowIndex + 1; i < n; i++
        // push to square: "[i, colIndex]"
        //
    //major diagonal
      // var targetColumn = colIndex + 1
      // targetRow = rowIndex + 1; targetRow < n && targetColumn < n; targetRow++
        // push to square: "[targetRow,targetColumn]"
        // currentColumn++

    //minor diagonal
      // targetColumn = colIndex - 1
      // targetRow = rowIndex + 1; targetRow < n && targetColumn >= 0; targetRow++
        // push to square: "[targetRow,targetColumn]"
        // currentColumn--

    //memoize
      // storage[stringifiedCoordinates] = square

  //addOrRemove(squares);

};

var addSquares = function (squares) {
};

var removeSquares = function (squares) {
};













